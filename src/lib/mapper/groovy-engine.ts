import { findNodeById, getFullPath, traverseDown } from "./node-utils"
import type {
    LoopCondition,
    LoopReference,
    MapperContext,
    MapperState,
    MapperTreeNode,
    SourceReference,
} from "./types"

// ============================================================
// Groovy Code Generation Engine
// ============================================================
// Mirrors engine.ts but outputs Groovy syntax instead of JavaScript.
// Generates Groovy scripts compatible with the legacy Vaadin platform.

// ============================================================
// Groovy string escaping
// ============================================================

/**
 * Escape a string for use in a Groovy double-quoted string or GString.
 * Escapes: backslash, double-quote, dollar-sign, newlines, tabs.
 */
export function escapeGroovyString(str: string): string {
    return str
        .replace(/\\/g, "\\\\")
        .replace(/"/g, '\\"')
        .replace(/\$/g, "\\$")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/\t/g, "\\t")
}

/**
 * Wrap a string value for Groovy output.
 * Uses triple-quoted strings for multi-line values, otherwise double-quoted.
 */
function quoteGroovyString(str: string): string {
    if (str.includes("\n") || str.includes("\r")) {
        // Triple-quoted GString — escape $ and backslash but keep newlines literal
        const escaped = str.replace(/\\/g, "\\\\").replace(/\$/g, "\\$")
        return `"""${escaped}"""`
    }
    return `"${escapeGroovyString(str)}"`
}

// ============================================================
// JS-to-Groovy lightweight reverse translation
// ============================================================

/**
 * Lightweight JavaScript-to-Groovy translator for code generated by this app.
 * Handles common patterns; not a full JS parser.
 */
export function translateJsToGroovy(jsCode: string): string {
    let code = jsCode

    // const / let → def
    code = code.replace(/\b(const|let)\s+/g, "def ")

    // === → ==
    code = code.replace(/===/g, "==")

    // !== → !=
    code = code.replace(/!==/g, "!=")

    // console.log(...) → println(...)
    code = code.replace(/\bconsole\.log\s*\(/g, "println(")

    // Template literal `...${expr}...` → GString "...${expr}..."
    // This regex handles simple backtick strings; nested backticks won't be supported
    code = code.replace(/`([^`]*)`/g, '"$1"')

    // .forEach( → .each {
    code = code.replace(
        /\.forEach\s*\(\s*(?:\(([^)]*)\)|(\w+))\s*=>\s*\{/g,
        (_, params, single) => {
            const arg = params || single
            return `.each { ${arg} ->`
        },
    )
    // .forEach(function(x) { → .each { x ->
    code = code.replace(/\.forEach\s*\(\s*function\s*\(([^)]*)\)\s*\{/g, ".each { $1 ->")

    // .filter( → .findAll {
    code = code.replace(/\.filter\s*\(\s*(?:\(([^)]*)\)|(\w+))\s*=>\s*\{/g, (_, params, single) => {
        const arg = params || single
        return `.findAll { ${arg} ->`
    })
    code = code.replace(
        /\.filter\s*\(\s*(?:\(([^)]*)\)|(\w+))\s*=>\s*([^{].*)/g,
        (_, params, single, body) => {
            const arg = params || single
            return `.findAll { ${arg} -> ${body}`
        },
    )

    // .map( → .collect {
    code = code.replace(/\.map\s*\(\s*(?:\(([^)]*)\)|(\w+))\s*=>\s*\{/g, (_, params, single) => {
        const arg = params || single
        return `.collect { ${arg} ->`
    })
    code = code.replace(
        /\.map\s*\(\s*(?:\(([^)]*)\)|(\w+))\s*=>\s*([^{].*)/g,
        (_, params, single, body) => {
            const arg = params || single
            return `.collect { ${arg} -> ${body}`
        },
    )

    // .find( → .find {
    code = code.replace(/\.find\s*\(\s*(?:\(([^)]*)\)|(\w+))\s*=>\s*/g, (_, params, single) => {
        const arg = params || single
        return `.find { ${arg} -> `
    })

    // .includes( → .contains(
    code = code.replace(/\.includes\s*\(/g, ".contains(")

    // .push( → .add(
    code = code.replace(/\.push\s*\(/g, ".add(")

    // .length → .size()
    code = code.replace(/\.length\b(?!\s*\()/g, ".size()")

    // parseInt( → .toInteger() — only simple cases
    code = code.replace(/parseInt\s*\(\s*(\w+)\s*\)/g, "$1.toInteger()")

    // parseFloat( → .toDouble()
    code = code.replace(/parseFloat\s*\(\s*(\w+)\s*\)/g, "$1.toDouble()")

    // JSON.parse( → new JsonSlurper().parseText(
    code = code.replace(/JSON\.parse\s*\(/g, "new groovy.json.JsonSlurper().parseText(")

    // Math.max(...arr) → arr.max()
    code = code.replace(/Math\.max\s*\(\s*\.\.\.(\w+)\s*\)/g, "$1.max()")

    // Math.min(...arr) → arr.min()
    code = code.replace(/Math\.min\s*\(\s*\.\.\.(\w+)\s*\)/g, "$1.min()")

    return code
}

// ============================================================
// Path encoding helpers (Groovy-specific)
// ============================================================

/**
 * Returns true for path segments that represent an array-child placeholder.
 */
function isArrayChildSegment(segment: string): boolean {
    return segment === "[]" || /^\[\d+\]$/.test(segment)
}

/**
 * Convert a node path fragment to a Groovy-safe accessor.
 * Uses safe-navigation operator (?.) for Groovy.
 */
function encodeGroovyPath(rawPath: string): string {
    if (!rawPath) return ""
    const parts = rawPath.split(".").filter((p) => p !== "" && !isArrayChildSegment(p))

    if (parts[0] === "root") parts.shift()

    return parts
        .map((p) => {
            if (p.startsWith("@")) return `["${p}"]`
            if (/[^a-zA-Z0-9_$]/.test(p)) return `["${p}"]`
            return `?.${p}`
        })
        .join("")
        .replace(/^\?\./, "") // strip leading ?.
}

/**
 * Build a Groovy safe-navigation data access path from sourceData or a loop iterator variable.
 */
function buildGroovySourceAccessPath(
    ref: SourceReference | LoopReference,
    sourceTree: MapperTreeNode,
    activeLoopRef: LoopReference | null,
    iterVar?: string,
): string {
    if (ref.customPath) return ref.customPath

    const sourceNode = findNodeById(ref.sourceNodeId, sourceTree)
    if (!sourceNode) return "null"

    const fullPath = getFullPath(ref.sourceNodeId, sourceTree)

    if (activeLoopRef && ref.loopOverId === activeLoopRef.id && iterVar) {
        const loopSourcePath = getFullPath(activeLoopRef.sourceNodeId, sourceTree)

        let relativePath = fullPath
        if (fullPath.startsWith(loopSourcePath)) {
            relativePath = fullPath.slice(loopSourcePath.length).replace(/^\./, "")
        }
        relativePath = relativePath.replace(/^\[\d*\]\.?/, "")

        if (!relativePath) return iterVar
        const encoded = encodeGroovyPath(relativePath)
        return encoded.startsWith("[") ? `${iterVar}${encoded}` : `${iterVar}?.${encoded}`
    }

    const encoded = encodeGroovyPath(fullPath)
    if (!encoded) return "sourceData"
    return encoded.startsWith("[") ? `sourceData${encoded}` : `sourceData?.${encoded}`
}

/**
 * Build a Groovy path for a loop source expression (the iterable array).
 */
function buildGroovyLoopSourcePath(loopRef: LoopReference, sourceTree: MapperTreeNode): string {
    if (loopRef.customPath) return loopRef.customPath

    const node = findNodeById(loopRef.sourceNodeId, sourceTree)
    if (!node) return "null"

    const fullPath = getFullPath(loopRef.sourceNodeId, sourceTree)

    if (node.type === "arrayChild") {
        const parentPath = fullPath.replace(/\.\[\]$/, "").replace(/\[\]$/, "")
        if (!parentPath) return "sourceData"
        const encoded = encodeGroovyPath(parentPath)
        return encoded.startsWith("[") ? `sourceData${encoded}` : `sourceData?.${encoded}`
    }

    const encoded = encodeGroovyPath(fullPath)
    if (!encoded) return "sourceData"
    return encoded.startsWith("[") ? `sourceData${encoded}` : `sourceData?.${encoded}`
}

/**
 * Build a loop condition path expression for Groovy.
 */
function buildGroovyLoopConditionPath(
    lc: LoopCondition,
    iterVar: string,
    sourceTree: MapperTreeNode,
    loopRef: LoopReference,
): string {
    const loopSourcePath = getFullPath(loopRef.sourceNodeId, sourceTree)

    let relativePath = lc.sourceNodePath
    if (relativePath.startsWith(loopSourcePath)) {
        relativePath = relativePath.slice(loopSourcePath.length).replace(/^\./, "")
    }
    relativePath = relativePath.replace(/^\[\]\.?/, "")

    if (!relativePath) return iterVar
    const encoded = encodeGroovyPath(relativePath)
    return encoded.startsWith("[") ? `${iterVar}${encoded}` : `${iterVar}?.${encoded}`
}

// ============================================================
// Value expression builder (Groovy)
// ============================================================

/**
 * Build a Groovy value expression for a target node.
 * Adds .toString()?.trim() ?: "" for text references.
 */
function buildGroovyValueExpression(node: MapperTreeNode): string | null {
    if (node.value) {
        return node.plainTextValue ? quoteGroovyString(node.value) : node.value
    }

    const refs = node.sourceReferences ?? []
    if (refs.length === 0) return null
    if (refs.length === 1) {
        return refs[0].variableName
    }

    // Multiple refs → GString interpolation
    const parts = refs.map((r) => `\${${r.variableName}}`).join("")
    return `"${parts}"`
}

// ============================================================
// Output path builder (Groovy)
// ============================================================

/**
 * Collect the ancestor chain from tree root to the target node (inclusive),
 * excluding the root itself.
 */
function getAncestorChain(nodeId: string, tree: MapperTreeNode): Array<MapperTreeNode> {
    const chain: Array<MapperTreeNode> = []

    function walk(current: MapperTreeNode): boolean {
        if (current.id === nodeId) {
            chain.push(current)
            return true
        }
        if (current.children) {
            for (const child of current.children) {
                if (walk(child)) {
                    if (current.id !== tree.id) chain.unshift(current)
                    return true
                }
            }
        }
        return false
    }

    walk(tree)
    return chain
}

/**
 * Build the Groovy left-hand-side output path for a target node.
 * Uses bracket notation for Groovy map access: output["field"]
 */
function buildGroovyOutputPath(
    node: MapperTreeNode,
    outputVar: string,
    targetTree: MapperTreeNode,
    arrayTempVars?: Map<string, string>,
): string {
    const chain = getAncestorChain(node.id, targetTree)
    if (chain.length === 0) return outputVar

    let accessor = outputVar
    let prevWasLoopArray = false
    let prevLoopArrayId: string | null = null

    for (const ancestor of chain) {
        const isArrayChildLike = ancestor.type === "arrayChild" || /^\[\d*\]$/.test(ancestor.name)
        if (isArrayChildLike) {
            if (prevWasLoopArray) {
                const tempVar = prevLoopArrayId ? arrayTempVars?.get(prevLoopArrayId) : undefined
                if (tempVar) {
                    accessor = tempVar
                } else {
                    accessor = `${accessor}[${accessor}.size() - 1]`
                }
                prevWasLoopArray = false
                prevLoopArrayId = null
            }
            continue
        }

        // Groovy map access uses bracket notation
        if (ancestor.name.startsWith("@")) {
            accessor = `${accessor}["${ancestor.name}"]`
        } else {
            accessor = `${accessor}["${ancestor.name}"]`
        }

        prevWasLoopArray = ancestor.type === "array" && !!ancestor.loopReference
        if (prevWasLoopArray) {
            prevLoopArrayId = ancestor.id
        }
    }

    return accessor
}

// ============================================================
// Section generators (Groovy)
// ============================================================

/**
 * Generate Groovy global variable declarations.
 */
function generateGroovyGlobalVariables(context: MapperContext): string {
    if (!context.globalVariables.length) return ""

    const lines = context.globalVariables.map((gv) => {
        const keyword = gv.isFinal ? "final def" : "def"
        const value = gv.plainTextValue ? quoteGroovyString(gv.value) : gv.value
        return `${keyword} ${gv.name} = ${value}`
    })
    return lines.join("\n")
}

/**
 * Generate Groovy lookup table declarations as map literals.
 */
function generateGroovyLookupTables(context: MapperContext): string {
    if (!context.lookupTables.length) return ""

    const lines = context.lookupTables.map((table) => {
        const entries = table.entries
            .map((e) => {
                const val = e.plainTextValue ? quoteGroovyString(e.value) : e.value
                return `  "${escapeGroovyString(e.key)}": ${val}`
            })
            .join(",\n")
        return `def ${table.name} = [\n${entries}\n]`
    })
    return lines.join("\n\n")
}

/**
 * Generate Groovy user-defined functions.
 * Functions are emitted as Groovy closures or verbatim if already Groovy.
 */
function generateGroovyFunctions(context: MapperContext): string {
    if (!context.functions.length) return ""
    return context.functions.map((f) => f.body.trim()).join("\n\n")
}

/**
 * Collect all source references not inside any loop scope and declare them at top level.
 * Adds .toString()?.trim() ?: "" for text references in Groovy style.
 */
function generateGroovySourceRefVariables(state: MapperState): string {
    if (!state.sourceTreeNode || !state.targetTreeNode) return ""

    const seen = new Set<string>()
    const lines: Array<string> = []

    traverseDown(state.targetTreeNode, (node) => {
        for (const ref of node.sourceReferences ?? []) {
            if (!ref.loopOverId && !seen.has(ref.id)) {
                seen.add(ref.id)
                const path = buildGroovySourceAccessPath(ref, state.sourceTreeNode!, null)
                if (ref.textReference) {
                    lines.push(`def ${ref.variableName} = ${path}?.toString()?.trim() ?: ""`)
                } else {
                    lines.push(`def ${ref.variableName} = ${path}`)
                }
            }
        }
    })

    return lines.join("\n")
}

// ============================================================
// Core recursive output generator (Groovy)
// ============================================================

/**
 * Recursively collect all refs in the subtree whose loopOverId matches the given loop id.
 */
function collectLoopScopedRefs(node: MapperTreeNode, loopId: string): Array<SourceReference> {
    const refs: Array<SourceReference> = []
    const seen = new Set<string>()

    function collect(n: MapperTreeNode): void {
        for (const ref of n.sourceReferences ?? []) {
            if (ref.loopOverId === loopId && !seen.has(ref.id)) {
                seen.add(ref.id)
                refs.push(ref)
            }
        }
        for (const child of n.children ?? []) {
            collect(child)
        }
    }

    collect(node)
    return refs
}

/**
 * Recursively generate Groovy code for a target node and all its children.
 * Mirrors generateTargetNode() from engine.ts but outputs Groovy syntax.
 */
function generateGroovyTargetNode(
    node: MapperTreeNode,
    state: MapperState,
    outputVar: string,
    indentLevel: number,
    activeLoopRef: LoopReference | null,
    activeIterVar: string | null,
    arrayTempVars?: Map<string, string>,
): string {
    const lines: Array<string> = []
    let indent = "    ".repeat(indentLevel)

    // 1. Code nodes — inject verbatim
    if (node.type === "code") {
        if (node.value) lines.push(indent + node.value)
        return lines.filter(Boolean).join("\n")
    }

    // 2. Node condition (outer if)
    const condition = node.nodeCondition
    const hasNodeCondition = condition && condition.condition && condition.condition.trim() !== ""
    if (hasNodeCondition) {
        lines.push(`${indent}if (${condition.condition}) {`)
        indentLevel++
        indent = "    ".repeat(indentLevel)
    }

    // 3. Loop reference
    const loopRef = node.loopReference
    let arrayTempVar: string | null = null
    let arrayArrPath: string | null = null
    if (loopRef) {
        const loopSource = node.loopStatement
            ? node.loopStatement
            : buildGroovyLoopSourcePath(loopRef, state.sourceTreeNode!)
        const iterVar = node.loopIterator || `_${loopRef.variableName}`
        lines.push(`${indent}${loopSource}?.each { ${iterVar} ->`)
        indentLevel++
        indent = "    ".repeat(indentLevel)

        // 3a. Loop conditions (filter)
        if (node.loopConditions && node.loopConditions.length > 0) {
            const connective = node.loopConditionsConnective === "OR" ? " || " : " && "
            const condParts = node.loopConditions.map((lc) => {
                const path = buildGroovyLoopConditionPath(
                    lc,
                    iterVar,
                    state.sourceTreeNode!,
                    loopRef,
                )
                return `${path}?.toString()?.trim() ${lc.condition}`
            })
            lines.push(`${indent}if (${condParts.join(connective)}) {`)
            indentLevel++
            indent = "    ".repeat(indentLevel)
        }

        // 3b. Initialize array target (build-then-push pattern for Groovy)
        if (node.type === "array") {
            const arrPath = buildGroovyOutputPath(
                node,
                outputVar,
                state.targetTreeNode!,
                arrayTempVars,
            )
            arrayArrPath = arrPath
            lines.push(`${indent}if (${arrPath} == null) ${arrPath} = []`)
            arrayTempVar = `_item_${indentLevel}`
            lines.push(`${indent}def ${arrayTempVar} = [:]`)
            if (!arrayTempVars) arrayTempVars = new Map()
            arrayTempVars.set(node.id, arrayTempVar)
        }

        // 3c. Declare refs scoped to this loop
        const scopeRefs = collectLoopScopedRefs(node, loopRef.id)
        for (const ref of scopeRefs) {
            const path = buildGroovySourceAccessPath(ref, state.sourceTreeNode!, loopRef, iterVar)
            if (ref.textReference) {
                lines.push(`${indent}def ${ref.variableName} = ${path}?.toString()?.trim() ?: ""`)
            } else {
                lines.push(`${indent}def ${ref.variableName} = ${path}`)
            }
        }
    }

    // 3d. Custom code block (injected verbatim)
    if (node.customCode?.trim()) {
        for (const codeLine of node.customCode.trim().split("\n")) {
            lines.push(indent + codeLine)
        }
    }

    // 4. Set value on this node (leaf assignment)
    const valueExpr = buildGroovyValueExpression(node)
    if (valueExpr !== null && node.type !== "array" && node.type !== "arrayChild") {
        const outputPath = buildGroovyOutputPath(
            node,
            outputVar,
            state.targetTreeNode!,
            arrayTempVars,
        )
        let line = `${indent}${outputPath} = ${valueExpr}`

        // Debug comment
        if (state.mapperPreferences.debugComment && node.sourceReferences?.length) {
            line += ` // ${node.sourceReferences.map((r) => r.variableName).join(", ")}`
        }
        lines.push(line)
    }

    // 5. Children recursion
    const childLoopRef = loopRef ?? activeLoopRef
    const childIterVar = loopRef ? node.loopIterator || `_${loopRef.variableName}` : activeIterVar
    for (const child of node.children ?? []) {
        const childCode = generateGroovyTargetNode(
            child,
            state,
            outputVar,
            indentLevel,
            childLoopRef,
            childIterVar,
            arrayTempVars,
        )
        if (childCode) lines.push(childCode)
    }

    // 5b. Conditional push — add temp item to array if it has properties
    if (loopRef && arrayTempVar && arrayArrPath) {
        lines.push(`${indent}if (${arrayTempVar}.size() > 0) {`)
        lines.push(`${indent}    ${arrayArrPath}.add(${arrayTempVar})`)
        lines.push(`${indent}}`)
    }

    // 6. Close loop conditions if block
    if (loopRef && node.loopConditions && node.loopConditions.length > 0) {
        indentLevel--
        indent = "    ".repeat(indentLevel)
        lines.push(`${indent}}`)
    }

    // 7. Close loop each block
    if (loopRef) {
        indentLevel--
        indent = "    ".repeat(indentLevel)
        lines.push(`${indent}}`)
    }

    // 8. Close node condition if block
    if (hasNodeCondition) {
        indentLevel--
        indent = "    ".repeat(indentLevel)
        lines.push(`${indent}}`)
    }

    return lines.filter((l) => l !== "").join("\n")
}

/**
 * Generate the output construction section from the target tree root's children.
 */
function generateGroovyOutputSection(state: MapperState): string {
    if (!state.targetTreeNode) return ""

    const lines: Array<string> = []
    lines.push("def output = [:]")

    for (const child of state.targetTreeNode.children ?? []) {
        const code = generateGroovyTargetNode(child, state, "output", 0, null, null)
        if (code) lines.push(code)
    }

    return lines.join("\n")
}

// ============================================================
// Import detection
// ============================================================

/**
 * Detects which Groovy/Java imports are needed based on the state's code.
 * Scans prolog/epilog, function bodies, global variable values, and custom code.
 */
export function detectRequiredImports(state: MapperState): string[] {
    const imports = new Set<string>()
    const codeFragments: string[] = []

    // Collect all code fragments to scan
    const ctx = state.localContext
    if (ctx.prologScript) codeFragments.push(ctx.prologScript)
    if (ctx.epilogScript) codeFragments.push(ctx.epilogScript)
    for (const f of ctx.functions) codeFragments.push(f.body)
    for (const gv of ctx.globalVariables) {
        if (!gv.plainTextValue) codeFragments.push(gv.value)
    }

    // Scan target tree for custom code
    if (state.targetTreeNode) {
        traverseDown(state.targetTreeNode, (node) => {
            if (node.customCode) codeFragments.push(node.customCode)
            if (node.value && !node.plainTextValue) codeFragments.push(node.value)
        })
    }

    const allCode = codeFragments.join("\n")

    // Pattern-based import detection
    if (/\bSimpleDateFormat\b/.test(allCode)) {
        imports.add("import java.text.SimpleDateFormat")
    }
    if (/\bZonedDateTime\b/.test(allCode)) {
        imports.add("import java.time.*")
    }
    if (/\bLocalDate\b/.test(allCode)) {
        imports.add("import java.time.*")
    }
    if (/\bLocalDateTime\b/.test(allCode)) {
        imports.add("import java.time.*")
    }
    if (/\bBigDecimal\b/.test(allCode)) {
        imports.add("import java.math.BigDecimal")
    }
    if (/\bLocale\b/.test(allCode)) {
        imports.add("import java.util.Locale")
    }
    if (/\bArrayList\b/.test(allCode)) {
        imports.add("import java.util.ArrayList")
    }
    if (/\bHashMap\b/.test(allCode)) {
        imports.add("import java.util.HashMap")
    }
    if (/\bCollections\b/.test(allCode)) {
        imports.add("import java.util.Collections")
    }
    if (/\bArrays\b/.test(allCode)) {
        imports.add("import java.util.Arrays")
    }
    if (/\bPattern\b|\bMatcher\b/.test(allCode)) {
        imports.add("import java.util.regex.*")
    }

    return Array.from(imports).sort()
}

// ============================================================
// XML output helper generation
// ============================================================

/**
 * Generate the Groovy XML output helper function string.
 */
function generateXmlOutputHelper(): string {
    return [
        "def buildXml(data) {",
        "    def writer = new StringWriter()",
        "    def xml = new groovy.xml.MarkupBuilder(writer)",
        "    xml.setDoubleQuotes(true)",
        "",
        "    def writeNode = { builder, key, value ->",
        "        if (value instanceof Map) {",
        '            builder."${key}" {',
        "                value.each { k, v ->",
        '                    if (k.startsWith("@")) {',
        "                        // attribute handled below",
        "                    } else {",
        "                        owner.call(builder, k, v)",
        "                    }",
        "                }",
        "            }",
        "        } else if (value instanceof List) {",
        "            value.each { item ->",
        "                owner.call(builder, key, item)",
        "            }",
        "        } else {",
        '            builder."${key}"(value?.toString() ?: "")',
        "        }",
        "    }",
        "",
        "    data.each { key, value ->",
        "        writeNode(xml, key, value)",
        "    }",
        "",
        "    return writer.toString()",
        "}",
    ].join("\n")
}

// ============================================================
// Main public API
// ============================================================

/**
 * Generates a Groovy script string from a MapperState.
 * Mirror of generateScript() from engine.ts but outputs Groovy syntax.
 */
export function generateGroovyScript(
    state: MapperState,
    inputType: "json" | "xml",
    outputType: "json" | "xml",
): string {
    const sections: Array<string> = []

    // 1. Imports
    const baseImports: string[] = []
    if (inputType === "json") {
        baseImports.push("import groovy.json.JsonSlurper")
    }
    if (inputType === "xml") {
        baseImports.push("import groovy.xml.XmlSlurper")
    }
    if (outputType === "json") {
        baseImports.push("import groovy.json.JsonBuilder")
    }
    if (outputType === "xml") {
        baseImports.push("import groovy.xml.MarkupBuilder")
    }

    // Detect additional imports from user code
    const additionalImports = detectRequiredImports(state)
    const allImports = [...new Set([...baseImports, ...additionalImports])]
    if (allImports.length > 0) {
        sections.push(allImports.join("\n"))
    }

    // 2. Parse input
    if (inputType === "xml") {
        sections.push("def sourceData = new XmlSlurper().parseText(input)")
    } else {
        sections.push("def sourceData = new JsonSlurper().parseText(input)")
    }

    // 3. Global variables
    const globalVarsCode = generateGroovyGlobalVariables(state.localContext)
    if (globalVarsCode) sections.push(globalVarsCode)

    // 4. Lookup tables
    const lookupCode = generateGroovyLookupTables(state.localContext)
    if (lookupCode) sections.push(lookupCode)

    // 5. User-defined functions
    const functionsCode = generateGroovyFunctions(state.localContext)
    if (functionsCode) sections.push(functionsCode)

    // 6. Prolog script (verbatim)
    if (state.localContext.prologScript?.trim()) {
        sections.push(state.localContext.prologScript.trim())
    }

    // 7. Top-level source reference variable declarations
    const sourceRefVars = generateGroovySourceRefVariables(state)
    if (sourceRefVars) sections.push(sourceRefVars)

    // 8. Output construction
    const outputSection = generateGroovyOutputSection(state)
    if (outputSection) sections.push(outputSection)

    // 9. Epilog script (verbatim)
    if (state.localContext.epilogScript?.trim()) {
        sections.push(state.localContext.epilogScript.trim())
    }

    // 10. XML output helper (if needed)
    if (outputType === "xml") {
        sections.push(generateXmlOutputHelper())
    }

    // 11. Return output
    if (outputType === "xml") {
        sections.push("return buildXml(output)")
    } else {
        sections.push("return new JsonBuilder(output).toPrettyString()")
    }

    return sections.join("\n\n")
}
